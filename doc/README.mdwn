Der Seee ("Sieh! Es erleichtert Evaluationen!")
===============================================

Übersicht
---------

Zu einer Vorlesungs- bzw. Veranstaltungsumfrage gehören mehrere
Teilaspekte, diese sind im Wesentlichen:

- Erhebung: Welche Veranstaltungen sollen mit welchen Fragen befragt
  werden
- Druck der entsprechenden Bögen
- aus den ausgefüllten Bögen digitalisierte Einträge in einer
  Datenbank machen
- diese Einträge auswerten

Selbstverständlich sind die einzelnen Punkte etwas diffiziler als
aufgeführt. Diese Dokumentation soll erklären, mit welcher Software
welcher dieser Schritte auf welche Art durchgeführt wird und wie das
auf MathPhys konkret aussieht.

Was ist der "Seee"?
-------------------

Als Seee ("Sieh! Es erleichtert Evaluationen!") wird einerseits im
Großen das gesamte Framework der Evaluation bezeichnet, welche alle in
der Übersicht aufgeführten Schritte umfasst. In dieser Verwendung
umfasst der Seee aber noch die "PEST" ("Praktische
EvaluationsSofTware"), welche aus den ausgefüllten Bögen
digitalisierte Einträge erstellt.

Im engeren Sinne meint "Seee" ein Webfrontend, mit dem die
Veranstaltungen, die beumfragt werden sollen, gesammelt werden und das
aus einer Datenbank hübsche Ergebnisse produziert. Diese Verwobenheit
ist dem Problem immanent und wird klar, wenn man sich die Struktur der
Daten in der Datenbank vergegenwärtigt.

Datenbanken und Tabellen - was steckt dahinter?
-----------------------------------------------

Die wichtigste Datenbank heißt auf MathPhys "`eval`", sie umfasst
viele verschiedene Tabellen mit Namen wie "`evaldaten_XYZ`". In ihr
sind die digitalisierten Fragebögen gespeichert. Eine Zeile (also ein
Eintrag) in der Tabelle korrespondiert mit genau einem ausgefüllten
Bogen. Ein ausgefüllter Bogen lässt abgesehen vom Barcode keine
Rückschlüsse auf die besuchte Veranstaltung zu.

Jede Spalte der Tabelle korrespondiert im Wesentlichen mit einer
Frage, wobei Multiple-Choice-Fragen in einer Art one-hot-Kodierung
gespeichert sind, indem für alle Antwortmöglichkeiten ein Feld `vX_a,
..., vX_n` exisiert. Damit korrespondieren verschiedene Tabellen nicht
nur mit verschiedenen Semestern, sondern auch mit verschiedenen
Fragebögen.

Die Daten in dieser Datenbank haben also keinerlei Informationen, auf
welche Veranstaltung sie sich beziehen. Sie sind damit nur ausgefüllte
Fragebögen und unabhängig von einer Veranstaltung.

Aus diesem Grund gibt es eine weitere Datenbank mit Namen "`seee`". In
dieser Datenbank sind genau diese Informationen gespeichert. Sie ist
essentiell, um aus abstrakten ausgefüllten Bögen konkrete Ergebnisse
zu generieren.


Und was ist jetzt der Seee im engeren Sinne?
--------------------------------------------

Der Seee im engeren Sinne ist ein (Web-)Frontend für die Datenbank
"seee". Es handelt sich um ein Ruby[^3]-on-Rails[^2]-Projekt, das auf
MathPhys unter [^1] gefunden werden kann.

Es ist *niemals* notwendig oder auch nur ratsam, direkt mit der
Datenbak "`seee`" zu arbeiten. Für das Überleben der Menschheit ist es
von *fundamentaler* Wichtigkeit, *ausschließlich* über das
Web-Frontend, eine Interactive Shell oder Skripte nach Vorbild des
`Rakefile`s (s.u.) auf die Datenbank zuzugreifen. Ruby-on-Rails
benutzt extensiv sog. "Object Relational Mapping" (ORM): Relationale
Einträge in der Datenbank werden als Instanzen von Ruby-Klassen
realisiert und sollten auch nur als solche Instanzen bearbeitet
werden!

Die zur Verfügung stehenden Klassen sind zum Beispiel `Prof`,
`Semester`, `Course`, `Tutor` etc. Eine `rdoc`-Dokumentation der
Ruby-Klassen und der Erweiterungen für die Auswertung gibt es
hier[^4]. Sie gibt auch einen Überblick über innere Zusammenhänge.

Ein wichtiges Hilfsmittel ist die Interactive Shell. Sie wird durch
Ausführen von `web/script/console` ausgeführt. Eine interactive
Shell ermöglicht es, live auf die Datenbank und die Methoden des Seees
zuzugreifen und Ruby-Code direkt ausführen zu können. Die interactive
Shell ist -- für den regulären Betrieb -- eigentlich nicht
notwendig. Eigentlich deshalb, weil sie sich bei unvorhergesehenen
Problemen als immens nützlich erwiesen hat. Wichtig ist dieses
Hilfsmittel, weil erfahrungsgemäß unvorhergesehen keinen
Seltenheitswert genießt.

Wir wollen uns aus diesem Grund ein paar Beispiele anschauen:

`>> s = Semester.find(4)`

`=> #<Semester id: 4, firstday: "2009-03-01", title: "SS 2009", [...]
>`

Die Methode `find` wird von Rails direkt mitgeliefert. Sie ist daher
nicht in dieser Dokumentation enthalten. Die Methode auch nicht
sonderlich empfehlenswert. `find` bekommt einen Integer (die
Datenbank-ID) oder ein Ruby-Symbol. Das wichtigste Ruby-Symbol lautet
`:all`, so würde

`semesters = Semester.find(:all)`

eine Liste aller Semester liefern. Listen dann sind wieder einfacher
zu benutzen: `s` ist jetzt ein bestimmtes Semester. Ein Semester hat
viele Kurse und folgerichtig das Objekt `s` eine Liste `s.courses`,
auf die wir normale Ruby-Sprachkonstrukte anwenden können:

`>> s.courses.find_all{ |c| c.fs_contact_adresses.empty? }.each{ |c| puts c.title }`

`Analysis 1`

`Experimentalphysik 3`

So würden wir uns händisch auf die Suche machen nach Kursen, in denen
keine Kontaktadresse zu finden ist. Generell ist der wichtigste
Einsatz von `find` wohl `XYZ.find(:all).find_all{ ... }`, wobei `XYZ`
natürlich `Semester`, `Course`, `Prof`, `Tutor` etc. sein könnte. Im
Gegensatz zu `find` ist `find_all` eine sehr empfehlenswerte Methode,
da sie es erlaubt, die Suchprädikate "rubyesque" zu schreiben (s.o.),
dokumentiert in der Ruby-Dokumentation.

Änderungen an Objekten durch die Interactive Shell bewirken Änderungen
in der Datenbank. Die `destroy`-Methode löscht Objekte, ebenfalls auch
aus der Datenbank.

### Technische Aspekte

Selbstverständlich wäre die Welt zu einfach, wäre der Seee im engeren
Sinne ein normales RoR-Projekt. Das Web-Interface ist in der Tat ein
sehr klassisches Projekt, das allerdings noch ein wenig Usability
vertragen könnte. In diesem Web-Interface können Veranstaltungen
angelegt etc. werden. Es gibt allerdings noch ein tolles Feature,
das zwar nicht zum Auswertungsteil gehört, aber dennoch nicht im
Web-Interface zu bedienen ist, das:

`Postoffice`
:	Das Postoffice kann Mails verschicken und hat dafür auch ein
	paar Routinen parat, die sich in
	`web/app/models/postoffice.rb` finden. Die Methode, um zum
	Beispiel eine Ankündigungsmail zu erstellen, ist
	`create_ankuendigungsmail` -- im Gegensatz zu
	`deliver_ankuendigungsmail`, welche die Mail auch
	gleich verschickt.

RoR ist überall hinreichend dokumentiert. Festzuhalten ist, dass das
RoR-root in `web/` ist. Pushes im `git`-Repository[^5] sorgen für `git
pull` in `/var/www-seee` auf MathPhys.

Die Auswertung ist praktisch vollständig in den *Models*[^6]
enthalten: `Semester` kann sich evaluieren, `Course` kann sich
evaluieren usw. Evaluieren heißt in diesem Kontext, echten harten
TeX-Output zu erzeugen, die Details erledigt `rake` (s.u.)

Für die Auswertung bedarf es einiger Klassen und Methoden. Alles
derartige ist im Verzeichnis `lib/` zu finden. Wie oben bereits
erwähnt, gibt es eine mehr oder weniger ausführliche
`rdoc`-Dokumentation zu alledem.

`Form.rb`
:	enthält Klasse für Bogen inkl. Fragen und Boxen. Ein Objekt
	der Klasse `Form` beschreibt einen Bogen.
`TeXQuestion.rb`
:	enthält Klasse, um Fragen wirklich auch als TeX ausgeben zu
	können 
`FunkyTeXBits.rb`
:	enthält gleichnamiges Mixin[^7], um zum Beispiel TeX-Header
	ausgeben zu können.
`FunkyDBBits.rb`
:	enthält gleichnamiges Mixin und kann den ganzen DB-Krimskrams,
	darunter auch Averages etc. rausfischen und so.
`rails_requirements.rb`
:	Datei, die alles wichtige required. Wird von **Rails**
	benutzt, dh eine Shell über `web/script/console` verfügt über
	alle tollen neuen Features.
`ext_requirements.rb, database.rb`
:	möchte man von außen auf das ORM zugreifen, sollten diese
	Dateien geladen werden

Die wichtigesten Begebenheit sind derart kommentiert, dass `rdoc` zu
passablen Ergebnissen führt.


### `rake` for the win

Um Ergebnisse der Evaluationen zu erstellen, verwenden wir `rake` --
ein Ruby-Analogon zu `make`. `rake` zu bedienen ist nicht weiter
schwierig, es gibt aber eine wesentliche Besonderheit: zwei
Rakefiles. Eines im Root-Verzeichnis des Repositories. Dieses
Rake-File kann echte Evaluationsergebnisse ausspucken. Andererseits
das Standard-Ruby-On-Rails-Rakefile im RoR-Root `web`. `rake -T` gibt
die möglichen Ziele (targets) aus. Ein möglicher Ablauf wäre:

`~/seee* rake -T`

`(in /home/oliver/seee)`

` ... `

`rake pdf:semester[semester_id]  # create pdf-file for a certain semester`

`~/seee* rake pdf:semester\[4\]`

`(in /home/oliver/seee)`

`Wrote ./tmp/Mathematik_SS_2009.tex`

`Wrote ./tmp/Mathematik_SS_2009.pdf`

`Wrote ./tmp/Physik_SS_2009.tex`

`Wrote ./tmp/Physik_SS_2009.pdf`

Die Backslashes um die eckigen Klammern werden in manchen Shells nicht
benötigt.

[^1]: [mathphys.fsk.uni-heidelberg.de/seee](https://mathphys.fsk.uni-heidelberg.de/seee)
[^2]: [Ruby-on-Rails-Doku](http://rubyonrails.org/documentation),
[Ruby-on-Rails-guides](http://guides.rubyonrails.org/)
[^3]: [Ruby-Doku](http://www.ruby-lang.org/de/documentation/)
[^4]: [rdoc-Doku des Projekts](http://mathphys.fsk.uni-heidelberg.de/~oliver/.seeedoc/app)
[^5]: [git](http://git-scm.com) ist ein verteiltes
Versionskontrollsystem
[^6]: RoR teilt Software in ein Model-View-Controller (MVC)-Schema
ein. Grob gesprochen sind Views das, was man im Webinterface sieht,
ein Controller ist das Ding, was die Objekte wirklich manipuliert und
ein Model ist die Repräsentation von Daten in einem abstrakten
Schema. Wir behaupten, dass die Ergebnisse einer Veranstaltungsumfrage
eine inhärente Eigenschaft dieser Veranstaltung ist und finden, dass
dieser Code in den Models am besten aufgehoben ist.
[^7]: Mixins sind Rubys Antwort auf Mehrfachvererbung:
Mehrfachvererbung ist böse, in verschiedenen Klassen benötigte
Funktionalität wird daher in "Mixins" ausgelagert.

Was ist also der Ablauf?
------------------------

Eine vollständige Evaluation besteht damit aus folgenden beinahe
einfachen Schritten:

1. Erhebung: Was soll evaluiert werden? Das in das Web-Interface
   "Seee" eintragen. Bei den Bögen aufpassen und immer gegenchecken in
   lib/forms
2. Eval ankündingen per Mail (dafür: `Postoffice`)
3. Bögen drucken: Im Seee erstellen lassen und ins URZ
   geben. Aufpassen, dass die nicht komisch in der Größe angepasst
   werden.
4. Austeilen, einsammeln, einscannen.
5. Digitalisieren, d.h. Optical Mark Recognition: dafür: PEST oder
   FormPro. Dazu: Andere Doku.
6. Sich `rake -T` anschauen und bedienen.
7. Profit.
