Der Seee ("Sieh! Es erleichtert Evaluationen!")
===============================================

Diese Dokumentation ist, im Rückblick, nicht ganz einfach zu
lesen. Das Projekt ist leider etwas komplex geworden und der Hang,
dass alles ein Akronym sein muss, hilft auch nicht.

Letztlich ist es nicht schwierig. Es ist nur viel und es hängt eng
zusammen. Es ist ratsam, vor dem Lesen der Dokumentation sich etwas
Ruby anzueignen. Ist objektorientierte Programmierung bekannt, ist die
[Doku von Mats](http://www.rubyist.net/~slagell/ruby/) vielleicht ein
sehr guter Einstieg. Die
[Rails-Screencasts](http://rubyonrails.org/screencasts) sind auch sehr
gut -- insbesondere, falls man noch nie mit einem Web-Framework
gearbeitet hat. Keine Angst, beides ist einfach (und macht auch
wirklich viel Spaß, sonst hätten wir das hier nie entwickelt).

Übersicht
---------

Zu einer Vorlesungs- bzw. Veranstaltungsumfrage gehören mehrere
Teilaspekte, diese sind im Wesentlichen:

- Erhebung: Welche Veranstaltungen sollen mit welchen Fragen befragt
  werden
- Druck der entsprechenden Bögen
- aus den ausgefüllten Bögen digitalisierte Einträge in einer
  Datenbank machen
- diese Einträge auswerten

Selbstverständlich sind die einzelnen Punkte etwas diffiziler als
aufgeführt. Diese Dokumentation soll erklären, mit welcher Software
welcher dieser Schritte auf welche Art durchgeführt wird und wie das
auf MathPhys konkret aussieht.

Was ist der "Seee"?
-------------------

Als Seee ("Sieh! Es erleichtert Evaluationen!") wird einerseits im
Großen das gesamte Framework der Evaluation bezeichnet, welche alle in
der Übersicht aufgeführten Schritte umfasst. In dieser Verwendung
umfasst der Seee aber noch die "PEST" ("Praktische
EvaluationsSofTware"), welche aus den ausgefüllten Bögen
digitalisierte Einträge erstellt.

Im engeren Sinne meint "Seee" ein Webfrontend, mit dem die
Veranstaltungen, die beumfragt werden sollen, gesammelt werden und das
aus einer Datenbank hübsche Ergebnisse produziert. Diese Verwobenheit
ist dem Problem immanent und wird klar, wenn man sich die Struktur der
Daten in der Datenbank vergegenwärtigt.

Datenbanken und Tabellen - was steckt dahinter?
-----------------------------------------------

Die wichtigste Datenbank heißt auf MathPhys "`eval`", sie umfasst
viele verschiedene Tabellen mit Namen wie "`evaldaten_XYZ`". In ihr
sind die digitalisierten Fragebögen gespeichert. Eine Zeile (also ein
Eintrag) in der Tabelle korrespondiert mit genau einem ausgefüllten
Bogen. Ein ausgefüllter Bogen lässt abgesehen vom Barcode keine
Rückschlüsse auf die besuchte Veranstaltung zu.

Jede Spalte der Tabelle korrespondiert im Wesentlichen mit einer
Frage, wobei Multiple-Choice-Fragen in einer Art one-hot-Kodierung
gespeichert sind, indem für alle Antwortmöglichkeiten ein Feld `vX_a,
..., vX_n` exisiert. Damit korrespondieren verschiedene Tabellen nicht
nur mit verschiedenen Semestern, sondern auch mit verschiedenen
Fragebögen.

Die Daten in dieser Datenbank haben also keinerlei Informationen, auf
welche Veranstaltung sie sich beziehen. Sie sind damit nur ausgefüllte
Fragebögen und unabhängig von einer Veranstaltung.

Aus diesem Grund gibt es eine weitere Datenbank mit Namen "`seee`". In
dieser Datenbank sind genau diese Informationen gespeichert. Sie ist
essentiell, um aus abstrakten ausgefüllten Bögen konkrete Ergebnisse
zu generieren.


Und was ist jetzt der Seee im engeren Sinne?
--------------------------------------------

Der Seee im engeren Sinne ist ein (Web-)Frontend für die Datenbank
"seee". Es handelt sich um ein Ruby[^3]-on-Rails[^2]-Projekt, das auf
MathPhys unter [^1] gefunden werden kann.

Es ist *niemals* notwendig oder auch nur ratsam, direkt mit der
Datenbak "`seee`" zu arbeiten. Für das Überleben der Menschheit ist es
von *fundamentaler* Wichtigkeit, *ausschließlich* über das
Web-Frontend, eine Interactive Shell oder Skripte nach Vorbild des
`Rakefile`s (s.u.) auf die Datenbank zuzugreifen. Ruby-on-Rails
benutzt extensiv sog. "Object Relational Mapping" (ORM): Relationale
Einträge in der Datenbank werden als Instanzen von Ruby-Klassen
realisiert und sollten auch nur als solche Instanzen bearbeitet
werden! Am besten ist es, die Existenz der Datenbank "`seee`" als
Implementationsdetail zu vergessen. Dass es sich im Grunde um eine
relationale Datenbank handelt, ist wohlversteckt.

Die für das Webfrontend zur Verfügung stehenden spannenden Klassen
sind `Prof`, `Semester`, `Course` und `Tutor`. Sie repräsentieren
offensichtlich alle Daten, die eine Vorlesung hat: Es gibt in einem
Semester viele Veranstaltungen, die je von ggf. mehreren Dozierenden
mit ggf. mehreren Tutor_innen gehalten werden.

Eine `rdoc`-Dokumentation der Ruby-Klassen und der Erweiterungen für
die Auswertung gibt es hier[^4]. Sie gibt auch einen Überblick über
innere Zusammenhänge (und offenbart, dass sich manche Menschen einfach
nicht an Naming Conventions halten können). Bemerkenswert ist das
Ruby-inhärente "principle of least surprise": Wie unten aus einer
beispielhaften Session klar wird, verhalten sich die Objekte durchaus,
wie man das erwartet. Geht es nur um Datenauswertung (werden also
keine Daten überschrieben), ist es unmöglich, irgendwas kaputt zu
machen. Erfahrungsgemäß macht der ein oder andere Runtime-Error mehr
Spaß als die Doku zu lesen.

Ein wichtiges Hilfsmittel ist die Interactive Shell. Sie wird durch
Ausführen von `web/script/console` ausgeführt. Eine interactive Shell
ermöglicht es, live auf die Datenbank und die Methoden des Seees
zuzugreifen und Ruby-Code direkt ausführen zu können. Es handelt sich
beinahe um die "normale" interaktive Ruby-Shell `irb`, nur dass ein
paar Skripte ausgeführt werden, dass auch die ganze zusätzliche Magie
funktioniert.

Die interactive Shell ist -- für den regulären Betrieb -- eigentlich
nicht notwendig. Eigentlich deshalb, weil sie sich bei
unvorhergesehenen Problemen als immens nützlich erwiesen hat. Wichtig
ist dieses Hilfsmittel, weil erfahrungsgemäß unvorhergesehen keinen
Seltenheitswert genießt.

Wir wollen uns aus diesem Grund ein paar Beispiele anschauen:

`>> s = Semester.find(4)`

`=> #<Semester id: 4, firstday: "2009-03-01", title: "SS 2009", [...]
>`

Die Methode `find` wird von Rails direkt mitgeliefert. Sie ist daher
nicht in dieser Dokumentation enthalten -- die Methode aber auch nicht
für komplexere Suchen sonderlich empfehlenswert. `find` bekommt einen
Integer (die Datenbank-ID) oder ein Ruby-Symbol. Das wichtigste
Ruby-Symbol lautet `:all`, so würde

`>> semesters = Semester.find(:all)`

eine Liste aller Semester liefern.

Generell ist der wichtigste Einsatz von `find` wohl
`XYZ.find(:all).find_all{ ... }`, wobei `XYZ` natürlich `Semester`,
`Course`, `Prof`, `Tutor` etc. sein könnte. Im Gegensatz zu `find` ist
`find_all` eine sehr empfehlenswerte Methode, da sie es erlaubt, die
Suchprädikate "rubyesque" zu schreiben (s.u.), dokumentiert in der
Ruby-Dokumentation.

Listen dann sind wieder einfacher zu benutzen: Statt der obigen
Zuweisung über die ID, ist

`>> s = Semester.find(:all).find { |s| s.now? }`

das Semester, das gerade stattfindet. Ein Semester hat viele Kurse und
folgerichtig das Objekt `s` eine Liste `s.courses`, auf die wir
normale Ruby-Sprachkonstrukte anwenden können:

`>> s.courses.find_all{ |c| c.evaluator.empty? }.each{ |c| puts c.title }`

`Analysis 1`

`Experimentalphysik 3`

So würden wir uns händisch auf die Suche machen nach Kursen, deren
Evaluation noch zu vergeben ist. Wir können die Werte auch direkt
verändern:

`>> s.courses.find_all{ |c| e.evaluator.empty? }.each{ |c| c.evaluator = 'fachschaft@mathphys.fsk.uni-heidelberg.de' }`

Alle Anfragen an die Evaluation dieser Vorlesung gehen dann an die
gesamte Fachschaft.

Änderungen an Objekten durch die Interactive Shell bewirken also
Änderungen in der Datenbank (genau, das war die Datenbank, die wir am
Anfang vergessen wollten). Die `destroy`-Methode löscht Objekte,
ebenfalls auch aus der Datenbank. Was in unserer Shell-Welt gelöscht
wird, ist auch in der Webinterface-Welt gelöscht. Einfach, weil es die
gleiche ist.

### Technische Aspekte

Selbstverständlich wäre die Welt zu einfach, wäre der Seee im engeren
Sinne ein normales RoR-Projekt. Das Web-Interface ist in der Tat ein
sehr klassisches Projekt (das allerdings noch ein wenig Usability
vertragen könnte). In diesem Web-Interface können Veranstaltungen
angelegt etc. werden. Es gibt allerdings noch ein tolles Feature, das
zwar nicht zum Auswertungsteil gehört, aber dennoch nicht im
Web-Interface zu bedienen ist, das:

`Postoffice`
:	Das Postoffice kann Mails verschicken und hat dafür auch ein
	paar Routinen parat, die sich in
	`web/app/models/postoffice.rb` finden. Die Methode, um zum
	Beispiel eine Ankündigungsmail zu erstellen, ist
	`create_ankuendigungsmail` -- im Gegensatz zu
	`deliver_ankuendigungsmail`, welche die Mail auch
	gleich verschickt.

RoR ist überall hinreichend dokumentiert. Festzuhalten ist, dass das
RoR-root in `web/` ist. Pushes im `git`-Repository[^5] sorgen für `git
pull` in `/var/www-seee` auf MathPhys.

Die Auswertung ist praktisch vollständig in den *Models*[^6]
enthalten: `Semester` kann sich evaluieren, `Course` kann sich
evaluieren usw. Evaluieren heißt in diesem Kontext, echten harten
TeX-Output zu erzeugen, um die Details kümmert sich `rake` (s.u.)

Für die Auswertung bedarf es einiger Klassen und Methoden. Von denen
ist im Webinterface praktisch nichts zu sehen. Alles derartige ist im
Verzeichnis `lib/` zu finden. Wie oben bereits erwähnt, gibt es eine
mehr oder weniger ausführliche `rdoc`-Dokumentation zu alledem.

`Form.rb`
:	enthält Klasse für Bogen inkl. Fragen und Boxen. Ein Objekt
	der Klasse `Form` beschreibt einen Bogen.
`TeXQuestion.rb`
:	enthält Klasse, um Fragen wirklich auch als TeX ausgeben zu
	können 
`FunkyTeXBits.rb`
:	enthält gleichnamiges Mixin[^7], um zum Beispiel TeX-Header
	ausgeben zu können.
`FunkyDBBits.rb`
:	enthält gleichnamiges Mixin und kann den ganzen DB-Krimskrams,
	darunter auch Averages etc. rausfischen und so.
`rails_requirements.rb`
:	Datei, die alles wichtige required. Wird von **Rails**
	benutzt, d.h. eine Shell über `web/script/console` verfügt über
	alle tollen neuen Features.
`ext_requirements.rb, database.rb`
:	möchte man von außen auf das ORM zugreifen, sollten diese
	Dateien geladen werden

Die wichtigesten Begebenheit sind derart kommentiert, dass `rdoc` zu
passablen Ergebnissen führt.

### `rake` for the win

Um Ergebnisse der Evaluationen zu erstellen, verwenden wir `rake` --
ein Ruby-Analogon zu `make`. `rake` zu bedienen ist nicht weiter
schwierig, es gibt aber eine wesentliche Besonderheit: zwei
Rakefiles. Eines im Root-Verzeichnis des Repositories. Dieses
Rake-File kann echte Evaluationsergebnisse ausspucken. Andererseits
das Standard-Ruby-On-Rails-Rakefile im RoR-Root `web`. `rake -T` gibt
die möglichen Ziele (targets) aus. Ein möglicher Ablauf wäre:

`~/seee* rake -T`

`(in /home/oliver/seee)`

` ... `

`rake pdf:semester[semester_id]  # create pdf-file for a certain semester`

`~/seee* rake pdf:semester\[4\]`

`(in /home/oliver/seee)`

`Wrote ./tmp/Mathematik_SS_2009.tex`

`Wrote ./tmp/Mathematik_SS_2009.pdf`

`Wrote ./tmp/Physik_SS_2009.tex`

`Wrote ./tmp/Physik_SS_2009.pdf`

Die Backslashes um die eckigen Klammern werden in manchen Shells nicht
benötigt.

Bemerkenswert (d.h. in diesem Fall: eigentlich eine nicht so gute
Idee, aber warum halt auch nicht) ist vielleicht, dass das Rakefile im
Root-Verzeichnis des Repositories auch die Pest steuert.

Als letzter Hinweis: Ruby wurde nicht ohne Grund ausgewählt. "Read the
source" ist bei diesem Projekt keine spöttische Bemerkung, sondern
häufig ein kurzer und prägnanter Weg, einiges zu verstehen.

[^1]: [mathphys.fsk.uni-heidelberg.de/seee](https://mathphys.fsk.uni-heidelberg.de/seee)
[^2]: [Ruby-on-Rails-Doku](http://rubyonrails.org/documentation),
[Ruby-on-Rails-guides](http://guides.rubyonrails.org/)
[^3]: [Ruby-Doku](http://www.ruby-lang.org/de/documentation/)
[^4]: [rdoc-Doku des Projekts](http://mathphys.fsk.uni-heidelberg.de/~oliver/.seeedoc/app)
[^5]: [git](http://git-scm.com) ist ein verteiltes
Versionskontrollsystem
[^6]: RoR teilt Software in ein Model-View-Controller (MVC)-Schema
ein. Grob gesprochen sind Views das, was man im Webinterface sieht,
ein Controller ist das Ding, was die Objekte wirklich manipuliert und
ein Model ist die Repräsentation von Daten in einem abstrakten
Schema. Wir behaupten, dass die Ergebnisse einer Veranstaltungsumfrage
eine inhärente Eigenschaft dieser Veranstaltung ist und finden, dass
dieser Code in den Models am besten aufgehoben ist.
[^7]: Mixins sind Rubys Antwort auf Mehrfachvererbung:
Mehrfachvererbung ist böse, in verschiedenen Klassen benötigte
Funktionalität wird daher in "Mixins" ausgelagert.

Was ist also der Ablauf?
------------------------

Eine vollständige Evaluation besteht damit aus folgenden beinahe
einfachen Schritten:

1. Erhebung: Was soll evaluiert werden? Das in das Web-Interface
   "Seee" eintragen. Bei den Bögen aufpassen und immer gegenchecken in
   lib/forms
2. Eval ankündingen per Mail (dafür: `Postoffice`)
3. Bögen drucken: Im Seee erstellen lassen und ins URZ
   geben. Aufpassen, dass die nicht komisch in der Größe angepasst
   werden.
4. Austeilen, einsammeln, einscannen.
5. Digitalisieren, d.h. Optical Mark Recognition: dafür: PEST oder
   FormPro. Dazu: Andere Doku.
6. Sich `rake -T` anschauen und bedienen.
7. Profit.
